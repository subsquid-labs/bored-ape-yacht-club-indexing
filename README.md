# [Bored Ape Yacht Club](https://boredapeyachtclub.com/) Indexer - A squid example for Ethereum network

<p align="center">
	<img src="assets/bayc_banner.png">
</p>

<div align="center">

[Twitter](https://twitter.com/subsquid) | [Discord](https://discord.gg/subsquid) | [LinkedIn](https://linkedin.com/subsquid) | [Telegram](https://t.me/HydraDevs) | [GitHub](https://github.com/subsquid) | [YouTube](https://www.youtube.com/@subsquid)

</div>

## Quick-start

<div align="center">

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io#https://github.com/RaekwonIII/bored-ape-yacht-club-indexing.git)

</div>

## Introduction

This project is a squid that indexes blockchain information generated by the [Bored Ape Yacht Club](https://etherscan.io/token/0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D) smart contract.

The transfers of Non Fungible Tokens related to the domain name are recorded by indexing the related `Transfer` event of the smart contract.

The contract information (name, symbol, total supply) is obtained using the related functions of the smart contract itself. This is thanks to the SDK, who is able to directly connect to the on-chain node.

Similarly, the token metadata, is obtained through the `tokenURI` function of the smart contract, but the indexer connects to a [Multicall contract](https://etherscan.io/token/0x5ba1e12693dc8f9c48aad8770482f4739beed696), the kind developed by [MakerDAO](https://github.com/makerdao/multicall).
The metadata itself is fetched via API requests, which is permitted by the SDK's flexibility.

Finally, a custom GraphQL resolver is implemented as a server extension (under `src/server-extension/resolvers`), to aggregate transfers data and return the total number of transfers for each day.

The project is relatively simple, because its purpose is purely demonstrative. Its intent is to showcase the capabilities of Subsquid SDK.

### What is a Squid?

> A squid is a project that extracts and transforms on-chain data in order to present it as a GraphQL API. Squids are developed using the Subsquid SDK, which provides extensive tooling to define data schemas, data transfomation rules, and the shape of the resulting API.

We recommend that you read Subsquid docs to understand how it works: https://docs.subsquid.io/

## Prerequisites

- Node 16.x
- Docker
- NPM

## Quick-start local indexing

1. Clone the repository
2. Install dependencies (in a console window): `npm i`
3. Build the project `sqd build`
4. Launch the database container `sqd up`
5. Launch the processor `sqd process`
6. Launch the GraphQL server (in a separate console window) `sqd serve`
7. Access the GraphiQL Playground, by running `sqd open http://localhost:4350/graphql` <!-- markdown-link-check-disable-line -->

## Key components

* The `schema.graphql` file is used to define the database and API schemas. A command line tool will automatically generate code from it, which you can find in `src/model/generated`
* The `db/migrations` folder contains automatically files with SQL statements to modify the database (create, alter, delete tables), similarly to any ORM database interface.
* The `src/abi` folder contains facade TypeScript code, automatically generated by a command line tool from one, or multiple smart contract ABI(s). This code is used to programmatically interface with the smart contract(s) and decode events and function calls.
* The main logic of this project is defined in `src/processor.ts`. The `EvmBatchProcessor` class is configured and used to perform request to [Subsquid's Archive for Ethereum blockchain](https://app.subsquid.io/archives), to obtain necessary data. Then some custom logic is implemented to process this data in batches, and save it on the database with the custom defined structure.

[Subsquid documentation](https://docs.subsquid.io/) has dedicated sections and pages describing each of these concepts, it is advised to consult them, before starting to develop your own squid.

## Development flow

## Dev flow

### 1. Define database schema

Start development by defining the schema of the target database via `schema.graphql`.
Schema definition consists of regular graphql type declarations annotated with custom directives.
Full description of `schema.graphql` dialect is available [here](https://docs.subsquid.io/basics/schema-file).

### 2. Generate TypeORM classes

Mapping developers use TypeORM [EntityManager](https://typeorm.io/#/working-with-entity-manager)
to interact with target database during data processing. All necessary entity classes are
generated by the squid framework from `schema.graphql`. This is done by running `sqd codegen`
command.

### 3. Generate database migrations

All database changes are applied through migration files located at `db/migrations`.
`squid-typeorm-migration(1)` tool provides several commands to drive the process.

```bash
## drop create the database
sqd down
sqd up

## replace any old schemas with a new one made from the entities
sqd migration:generate
```
See [docs on database migrations](https://docs.subsquid.io/basics/db-migrations) for more details.

### 4. Import ABI contract and generate interfaces to decode events

It is necessary to import the respective ABI definition to decode EVM logs. One way to generate a type-safe facade class to decode EVM logs is by placing the relevant JSON ABIs to `./abi`, then using `squid-evm-typegen(1)` via an `sqd` script:

```bash
sqd typegen
```

See more details on the [`squid-evm-typegen` doc page](https://docs.subsquid.io/evm-indexing/squid-evm-typegen).

## Project conventions

Squid tools assume a certain project layout.

* All compiled js files must reside in `lib` and all TypeScript sources in `src`.
The layout of `lib` must reflect `src`.
* All TypeORM classes must be exported by `src/model/index.ts` (`lib/model` module).
* Database schema must be defined in `schema.graphql`.
* Database migrations must reside in `db/migrations` and must be plain js files.
* `sqd(1)` and `squid-*(1)` executables consult `.env` file for a number of environment variables.

## GraphQL server extensions

It is possible to extend `squid-graphql-server(1)` with custom
[type-graphql](https://typegraphql.com) resolvers and to add request validation. See [the docs](https://docs.subsquid.io/develop-a-squid/graphql-api/custom-resolvers/) for more details.
